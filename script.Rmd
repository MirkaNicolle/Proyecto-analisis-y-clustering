---
title: "Proyecto analisis exploratorio y clustering"
author: "Andres Quinto, Mirka Monzon, Oscar De Leon, Oscar Ramos, Diego Crespo"
date: "26/03/2022"
output: 
  html_document:
    code_folding: hide
    word_document: default
    pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(haven)
library(foreign)

datos2015 <- read_sav("./SAVS/2015M.sav")
options(java.parameters = "-Xmx8000m")

#NO FUE NECESARIO REALIZAR CAMBIOS 

```


```{r}
library(haven)
library(foreign)

datosNacim2015 <- read_sav("./SAVS/2015N.sav")

#NO FUE NECESARIO REALIZAR CAMBIOS

```


```{r}
library(haven)
library(foreign)

datosNacim2016 <- read_sav("./SAVS/2016N.sav")

#NO FUE NECESARIO REALIZAR CAMBIOS

```

```{r}
library(haven)
library(foreign)

datos2016 <- read_sav("./SAVS/2016M.sav")

#NO FUE NECESARIO REALIZAR CAMBIOS

```

```{r}
library(haven)
library(foreign)

datosNacim2019 <- read_sav("./2019N.sav")

#NO FUE NECESARIO REALIZAR CAMBIOS

```


```{r}
library(haven)
library(foreign)

datos2015 <- read_sav("./SAVS/2015M.sav")

#NO FUE NECESARIO REALIZAR CAMBIOS 

```


```{r}
library(haven)
library(foreign)

datosNacim2015 <- read_sav("./SAVS/2015N.sav")

#NO FUE NECESARIO REALIZAR CAMBIOS

```


```{r}
library(haven)
library(foreign)

datosNacim2016 <- read_sav("./SAVS/2016N.sav")

#NO FUE NECESARIO REALIZAR CAMBIOS

```

```{r}
library(haven)
library(foreign)

datos2016 <- read_sav("./SAVS/2016M.sav")

#NO FUE NECESARIO REALIZAR CAMBIOS

```

```{r}
library(haven)
library(foreign)

datosNacim2019 <- read_sav("./2019N.sav")

#NO FUE NECESARIO REALIZAR CAMBIOS

```

```{r}
#install.packages("tidyverse")
library(tidyverse)
library(haven)
library(foreign)
#Lectura y conversion de los .SAV

# Comentados los savs que ya fueron convertidos en .csv
# write.csv(X2011, 'X2011.csv')
# write.csv(X2012, 'X2012.csv')
# write.csv(X2013, 'X2013.csv')
# write.csv(base1, 'base1.csv')
# write.csv(X2016, 'X2016.csv')
# write.csv(matri2014, 'matri2014 .csv')
# write.csv(matri2015 , 'matri2015 .csv')
# write.csv(matri2016 , 'matri2016 .csv')
# 

datos2011 <- read_sav("./SAVS/20111.sav")
datos2012 <- read_sav("./SAVS/20122.sav")
datosNacim2011 <- read_sav("./SAVS/2011N.sav")
datosNacim2012 <- read_sav("./SAVS/nacim2012.sav")
datos2019 <- read_sav("./SAVS/2019M.sav")

#---------------------Modificaciones 2011----------------------
#Crear columnas en dataset 2011 NUNUHO, NUNUMU
NUNUHO <- rnorm(nrow(datos2011))
datos2011 <- cbind(datos2011,NUNUHO)
datos2011$NUNUHO <- "None"
NUNUMU <- rnorm(nrow(datos2011))
datos2011 <- cbind(datos2011, NUNUMU)
datos2011$NUNUMU <- "None"
#Poner todas en uppercase 2011
cnames <- colnames(datos2011)
mayu2011 = c()
for (i in 1:length(cnames)){
  mayu2011[i] <- toupper(cnames[i])  
}
colnames(datos2011)<-mayu2011
#cambiar AREAG por AREAGOCU, OCUHOM, OCUMUJ, PUEHOM, PUEMUJ
cnames <- colnames(datos2011)
nombresN = c()
for(i in 1:length(cnames)){
  if(cnames[i] == "AREAG"){
    nombresN[i] <- "AREAGOCU"
  }
  else if(cnames[i] == "OCUHOM"){
    nombresN[i] <- "CIUOHOM"
  }
  else if(cnames[i] == "OCUMUJ"){
    nombresN[i] <- "CIUOMUJ"
  }
  else if(cnames[i] == "GETHOM"){
    nombresN[i] <- "PUEHOM"
  }
  else if(cnames[i] == "GETMUJ"){
    nombresN[i] <- "PUEMUJ"
  }
  else{
    nombresN[i] <- cnames[i]
  }
}
colnames(datos2011) <- nombresN

#-------------------------Modificaciones 2012------------------------

#Crear columnas en dataset 2012 AÑOOCU, NUNUHO, NUNUMU
AÑOOCU <- rnorm(nrow(datos2012))
datos2012 <- cbind(datos2012, AÑOOCU)
datos2012$AÑOOCU <- "None"
NUNUHO <- rnorm(nrow(datos2012))
datos2012 <- cbind(datos2012,NUNUHO)
datos2012$NUNUHO <- "None"
NUNUMU <- rnorm(nrow(datos2012))
datos2012 <- cbind(datos2012, NUNUMU)
datos2012$NUNUMU <- "NA"
#View(datos2012)
#cambiar AREAG por AREAGOCU, OCUHOM, OCUMUJ, PUEHOM, PUEMUJ
cnames <- colnames(datos2012)
nombresN = c()
for(i in 1:length(cnames)){
  if(cnames[i] == "AREAG"){
    nombresN[i] <- "AREAGOCU"
  }
  else if(cnames[i] == "OCUHOM"){
    nombresN[i] <- "CIUOHOM"
  }
  else if(cnames[i] == "OCUMUJ"){
    nombresN[i] <- "CIUOMUJ"
  }
  else if(cnames[i] == "GETHOM"){
    nombresN[i] <- "PUEHOM"
  }
  else if(cnames[i] == "GETMUJ"){
    nombresN[i] <- "PUEMUJ"
  }
  else{
    nombresN[i] <- cnames[i]
  }
}
colnames(datos2012) <- nombresN
#datos2012$AÑOOCU <- ifelse(datos2012$AÑOOCU == 'None', 2012, datos2012$AÑOOCU)

#-------------------------Modificaciones 2019------------------------
#Agregar columna areagocu
#Poner todas en uppercase 2019
AREAGOCU <- rnorm(nrow(datos2019))
datos2019 <- cbind(datos2019, AREAGOCU)
datos2019$AREAGOCU <- "None"

#-------------------------Modificaciones Nacimientos 2019------------------------
cnames <- colnames(datosNacim2019)
mayu2011 = c()
for (i in 1:length(cnames)){
  mayu2011[i] <- toupper(cnames[i])  
}
colnames(datosNacim2019)<-mayu2011
#CAMBIOS DE BASE NACIMIENTOS 2011 PARA QUE SEA SIMILAR A 2019
#Poner todas en uppercase 2011
cnames <- colnames(datosNacim2011)
mayu2011 = c()
for (i in 1:length(cnames)){
  mayu2011[i] <- toupper(cnames[i])  
}
colnames(datosNacim2011)<-mayu2011

#Cambiar MUPNAP a MUNPNAP
cnames <- colnames(datosNacim2011)
nombresN = c()
for(i in 1:length(cnames)){
  if(cnames[i] == "MUPNAP"){
    nombresN[i] <- "MUNPNAP"
  }
}
#AGREGAR LAS COLUMNAS FALTANTES Y LLENARLAS DE NONE
TIPOINS <- rnorm(nrow(datosNacim2011))
datosNacim2011 <- cbind(datosNacim2011, TIPOINS)
datosNacim2011$TIPOINS <- "None"

VIAPAR <- rnorm(nrow(datosNacim2011))
datosNacim2011 <- cbind(datosNacim2011, VIAPAR)
datosNacim2011$VIAPAR <- "None"

PAISREP <- rnorm(nrow(datosNacim2011))
datosNacim2011 <- cbind(datosNacim2011, PAISREP)
datosNacim2011$PAISREP <- "None"

PUEBLOPP <- rnorm(nrow(datosNacim2011))
datosNacim2011 <- cbind(datosNacim2011, PUEBLOPP)
datosNacim2011$PUEBLOPP <- "None"

PAISNACP <- rnorm(nrow(datosNacim2011))
datosNacim2011 <- cbind(datosNacim2011, PAISNACP)
datosNacim2011$PAISNACP <- "None"

PAISREM <- rnorm(nrow(datosNacim2011))
datosNacim2011 <- cbind(datosNacim2011, PAISREM)
datosNacim2011$PAISREM <- "None"

PUEBLOPM <- rnorm(nrow(datosNacim2011))
datosNacim2011 <- cbind(datosNacim2011, PUEBLOPM)
datosNacim2011$PUEBLOPM <- "None"

PAISNACM <- rnorm(nrow(datosNacim2011))
datosNacim2011 <- cbind(datosNacim2011, PAISNACM)
datosNacim2011$PAISNACM <- "None"
#ELIMINAMOS LAS COLUMNAS EXTRAS

datosNacim2011 = datosNacim2011[,!(names(datosNacim2011) %in% c("AREAG","GRETNP", "NACIOP","GRUPETMA","NACIOM"))]

#CAMBIOS DE BASE NACIMIENTOS 2012 PARA QUE SEA SIMILAR A 2019
#Poner todas en uppercase 2012
cnames <- colnames(datosNacim2012)
mayu2011 = c()
for (i in 1:length(cnames)){
  mayu2011[i] <- toupper(cnames[i])  
}
colnames(datosNacim2012)<-mayu2011

#Cambiar MUPNAP a MUNPNAP
cnames <- colnames(datosNacim2012)
nombresN = c()
for(i in 1:length(cnames)){
  if(cnames[i] == "MUPNAP"){
    nombresN[i] <- "MUNPNAP"
  }
}
#AGREGAR LAS COLUMNAS FALTANTES Y LLENARLAS DE NONE
TIPOINS <- rnorm(nrow(datosNacim2012))
datosNacim2012 <- cbind(datosNacim2012, TIPOINS)
datosNacim2012$TIPOINS <- "None"

VIAPAR <- rnorm(nrow(datosNacim2012))
datosNacim2012 <- cbind(datosNacim2012, VIAPAR)
datosNacim2012$VIAPAR <- "None"

PAISREP <- rnorm(nrow(datosNacim2012))
datosNacim2012 <- cbind(datosNacim2012, PAISREP)
datosNacim2012$PAISREP <- "None"

PUEBLOPP <- rnorm(nrow(datosNacim2012))
datosNacim2012 <- cbind(datosNacim2012, PUEBLOPP)
datosNacim2012$PUEBLOPP <- "None"

PAISNACP <- rnorm(nrow(datosNacim2012))
datosNacim2012 <- cbind(datosNacim2012, PAISNACP)
datosNacim2012$PAISNACP <- "None"

PAISREM <- rnorm(nrow(datosNacim2012))
datosNacim2012 <- cbind(datosNacim2012, PAISREM)
datosNacim2012$PAISREM <- "None"

PUEBLOPM <- rnorm(nrow(datosNacim2012))
datosNacim2012 <- cbind(datosNacim2012, PUEBLOPM)
datosNacim2012$PUEBLOPM <- "None"

PAISNACM <- rnorm(nrow(datosNacim2012))
datosNacim2012 <- cbind(datosNacim2012, PAISNACM)
datosNacim2012$PAISNACM <- "None"
#ELIMINAMOS LAS COLUMNAS EXTRAS

datosNacim2012 = datosNacim2012[,!(names(datosNacim2012) %in% c("AREAG","GRETNP", "NACIOP","GRUPETMA","NACIOM"))]
```

```{r}
library(haven)
library(foreign)

datos2013 <- read_sav("./SAVS/2013M.sav")

#-------------------------Modificaciones 2013 matrimonios------------------------
#columnas a crear para año 2013: NUNUHO, NUNUMU
#no hay columnas para cambiar 

#NUNUHO
NUNUHO <- rnorm(nrow(datos2013))
datos2013 <- cbind(datos2013,NUNUHO)
datos2013$NUNUHO <- "None"

#NUNUMU
NUNUMU <- rnorm(nrow(datos2013))
datos2013 <- cbind(datos2013, NUNUMU)
datos2013$NUNUMU <- "NA"

```

```{r}
library(haven)
library(foreign)

datos2014 <- read_sav("./SAVS/2014M.sav")

#-------------------------Modificaciones 2014 matrimonios------------------------
#columnas a crear para año 2014: NUNUHO, NUNUMU
#no hay comunas para cambiar 

#NUNUHO
NUNUHO <- rnorm(nrow(datos2014))
datos2014 <- cbind(datos2014,NUNUHO)
datos2014$NUNUHO <- "None"

#NUNUMU
NUNUMU <- rnorm(nrow(datos2014))
datos2014 <- cbind(datos2014, NUNUMU)
datos2014$NUNUMU <- "NA"

#Agregar columna anoocu
AÑOOCU <- rnorm(nrow(datos2014))
datos2014 <- cbind(datos2014, AÑOOCU)
datos2014$AÑOOCU <- "None"
```

```{r}
library(haven)
library(foreign)

datosN2013 <- read_sav("./SAVS/2013N.sav")

#-------------------------Modificaciones 2013 nacimientos------------------------
#columnas a crear para año 2013: TIPOINS, AÑOOCU, VIAPAR 
#columnas a cambiar: CIUPAD - OCUPAP / CIUMAD - OCUPAM
#columnas a borrar: NACIOP, ESCOLAP, NACIOM 

#TIPOINS
TIPOINS <- rnorm(nrow(datosN2013))
datosN2013 <- cbind(datosN2013,TIPOINS)
datosN2013$TIPOINS <- "None"

#AÑOOCU
AÑOOCU <- rnorm(nrow(datosN2013))
datosN2013 <- cbind(datosN2013,AÑOOCU)
datosN2013$AÑOOCU <- "None"

#VIAPAR
VIAPAR <- rnorm(nrow(datosN2013))
datosN2013 <- cbind(datosN2013,VIAPAR)
datosN2013$VIAPAR <- "None"

#cambio de nombre de columnas
cnames <- colnames(datosN2013)
nombresN = c()
for(i in 1:length(cnames)){
  if(cnames[i] == "CIUPAD"){
    nombresN[i] <- "OCUPAP"
  }
  else if(cnames[i] == "CIUMAD"){
    nombresN[i] <- "OCUPAM"
  }
  else{
    nombresN[i] <- cnames[i]
  }
}
colnames(datosN2013) <- nombresN

#drop NACIOP
datosN2013$NACIOP <- NULL

#drop ESCOLAP
datosN2013$ESCOLAP <- NULL

#drop NACIOM
datosN2013$NACIOM <- NULL
```

```{r}
library(haven)
library(foreign)

datosN2014 <- read_sav("./SAVS/2014N.sav")

#-------------------------Modificaciones 2014 nacimientos------------------------
#columnas a crear para año 2013: TIPOINS, AÑOOCU, VIAPAR, OCUPAP
#columnas a cambiar: NA
#columnas a borrar: CIUMAD  

#TIPOINS
TIPOINS <- rnorm(nrow(datosN2014))
datosN2014 <- cbind(datosN2014,TIPOINS)
datosN2014$TIPOINS <- "None"

#AÑOOCU
AÑOOCU <- rnorm(nrow(datosN2014))
datosN2014 <- cbind(datosN2014,AÑOOCU)
datosN2014$AÑOOCU <- "None"

#VIAPAR
VIAPAR <- rnorm(nrow(datosN2014))
datosN2014 <- cbind(datosN2014,VIAPAR)
datosN2014$VIAPAR <- "None"

#OCUPAP
OCUPAP <- rnorm(nrow(datosN2014))
datosN2014 <- cbind(datosN2014,OCUPAP)
datosN2014$OCUPAP <- "None"

#drop CIUMAD
datosN2014$CIUMAD <- NULL
```


```{r}
library(haven)
library(foreign)

datos2013 <- read_sav("./SAVS/2013M.sav")

#-------------------------Modificaciones 2013------------------------
#columnas a crear para año 2013: NUNUHO, NUNUMU
#no hay columnas para cambiar 
#columnas por borrar: x

#NUNUHO
NUNUHO <- rnorm(nrow(datos2013))
datos2013 <- cbind(datos2013,NUNUHO)
datos2013$NUNUHO <- "None"

#NUNUMU
NUNUMU <- rnorm(nrow(datos2013))
datos2013 <- cbind(datos2013, NUNUMU)
datos2013$NUNUMU <- "NA"

#Agregar columna anoocu
AÑOOCU <- rnorm(nrow(datos2013))
datos2013 <- cbind(datos2013, AÑOOCU)
datos2013$AÑOOCU <- "None"
```


```{r}
#UNIMOS LAS BASES DE MATRIMONIOS DEL 2011 AL 2016
#---------- Ya con todas las bases con las mismas columnas (cant columnas y nombres) podemos unirlas 

#install.packages("sf")
library(dplyr)
library(sf)
#------------------------Unión de las bases-------------------------
datos2011 <- datos2011 %>%
  mutate_if(is.labelled,list(as_factor))
datos2012 <- datos2012 %>%
  mutate_if(is.labelled,list(as_factor))
datos2013 <- datos2013 %>%
  mutate_if(is.labelled,list(as_factor))
datos2014 <- datos2014 %>%
  mutate_if(is.labelled,list(as_factor))
datos2015 <- datos2015 %>%
  mutate_if(is.labelled,list(as_factor))
datos2016 <- datos2016 %>%
  mutate_if(is.labelled,list(as_factor))

l = list(datos2011,datos2012,datos2013,datos2014,datos2015,datos2016)
datosMatrimonio <- do.call("rbind",l)
datosMatrimonio$EDADHOM <- as.numeric(factor(datosMatrimonio$EDADHOM))
datosMatrimonio$EDADMUJ <- as.numeric(factor(datosMatrimonio$EDADMUJ))

datosMatrimonio$ESCHOM <- ifelse(datosMatrimonio$ESCHOM == "DIversificado","Diversificado",datosMatrimonio$ESCHOM)
datosMatrimonio$ESCHOM <- ifelse(datosMatrimonio$ESCHOM == "Post Grado","Universitario",datosMatrimonio$ESCHOM)
datosMatrimonio$ESCHOM <- ifelse(datosMatrimonio$ESCHOM == "Postgrado","Universitario",datosMatrimonio$ESCHOM)
datosMatrimonio$ESCMUJ <- ifelse(datosMatrimonio$ESCMUJ == "DIversificado","Diversificado",datosMatrimonio$ESCMUJ)
datosMatrimonio$ESCMUJ <- ifelse(datosMatrimonio$ESCMUJ == "Post Grado","Universitario",datosMatrimonio$ESCMUJ)
datosMatrimonio$ESCMUJ <- ifelse(datosMatrimonio$ESCMUJ == "Postgrado","Universitario",datosMatrimonio$ESCMUJ)


datosMatrimonio$DEPOCU <- levels(datosMatrimonio$DEPOCU)[datosMatrimonio$DEPOCU]
datosMatrimonio$DEPOCU <- ifelse(datosMatrimonio$DEPOCU == "Totonicapán","Totonicapan",datosMatrimonio$DEPOCU)
datosMatrimonio$DEPOCU <- ifelse(datosMatrimonio$DEPOCU == "Petén","Peten",datosMatrimonio$DEPOCU)
datosMatrimonio$DEPOCU <- factor(datosMatrimonio$DEPOCU)


datosMatrimonio$PUEHOM <- levels(datosMatrimonio$PUEHOM)[datosMatrimonio$PUEHOM]
datosMatrimonio$PUEMUJ <- levels(datosMatrimonio$PUEMUJ)[datosMatrimonio$PUEMUJ]

datosMatrimonio$PUEHOM <- ifelse(datosMatrimonio$PUEHOM == "No Indigena", "No indigena",datosMatrimonio$PUEHOM)
datosMatrimonio$PUEMUJ <- ifelse(datosMatrimonio$PUEMUJ == "No Indigena", "No indigena",datosMatrimonio$PUEMUJ)


datosMatrimonio$PUEHOM <- factor(datosMatrimonio$PUEHOM)
datosMatrimonio$PUEMUJ <- factor(datosMatrimonio$PUEMUJ)

```
## Informe de análisis exploratorio 

A continuación la explicación de qué representa cada una de las variables:
DEPREG: departamento de registro
MUPREG: municipio de registro
MESREG: mes de registro
AÑOREG: año de registro
CLAUNI: clase de unión
EDADHOM: edad del hombre
EDADMUJ: edad de la mujer
PUEHOM: etnia del hombre
PUEMUJ: etnia de la mujer
NACHOM: nacionalidad del hombre
NACMUJ: nacionalidad de la mujer
CIUOHOM: ocupación del hombre
CIUOMUJ: ocupación de la mujer
NUNUHO: número de nupcias del hombre
NUNUMU: número de nupcias de la mujer
DEPOCU: departamento de ocurrencia
MUPOCU: municipio de ocurrencia
MESOCU: mes de ocurrencia
AÑOOCU: año de ocurrencia
AREAGOCU: área geográfica de ocurrencia
ESCHOM: escolaridad del hombre
ESCMUJ: escolaridad de la mujer

En el siguiente cuadro se muestra el tipo de dato de cada una de las variables mencionadas anteriormente:


```{r data, echo=FALSE}
#
str(datosMatrimonio)
```

Las variables más interesantes para el porpósito de la investigación son las que proporcionan información de la fecha del matrimonio. Otras con gran potencial son las edades de los cónyuges, ya que con ellas podemos analizar cual es la tendencia de matrimonios de menores, diferencias de edades etc.

## Análisis de variables cuantitativas
### Registros de matrimonio
#### Prueba de normalidad para  registros de matrimonios:

```{r normalHist, echo=FALSE}
#install.packages("ggplot2",repos = "http://cran.us.r-project.org")
library (ggplot2)
ggplot(data = datosMatrimonio, aes(x = AÑOREG)) + 
  geom_histogram(aes(y=..density.., fill = ..count..))+
  scale_fill_gradient(low = "#DCDCDC", high = "#7C7C7C")+
  stat_function(fun = dnorm, colour = "firebrick",
                args = list(mean = mean(datosMatrimonio$popularity),
                            sd = sd(datosMatrimonio$popularity)))+
  ggtitle("Histograma con curva normal teórica de los registros de matrimonios por año (2011 - 2016)") + 
  theme_bw()
```  

Como es de esperarse, no es posible observar que exista una relación en el histograma de registros de matrimonios con las reformas planteadas para la prohibición de matrimonios con menores de edad, ya que parece que la cantidad de matrimonios ha sido bastante constante durante los años. Según el histograma mostrado, la cantidad de matrimonios por año no sigue una distribución normal.


```{r normalBox, echo=FALSE}
boxplot(datosMatrimonio$AÑOREG, main = "Caja y Bigotes de registro de matrimonios por año (2011 - 2017)", xlab = "Registro por año")
```

Como dicho anteriormente, no hay muchos grupos atípicos ya que se concentran dentro de un intervalo.Según este diagrama, sí se cuenta con normalidad en la cantidad de matrimonios por año.

### Diagrama de qqnormal 

```{r normalQQ, echo=FALSE}
qqnorm(datosMatrimonio$AÑOREG, col="blue")
qqline(datosMatrimonio$AÑOREG, col="red")
```

Aunque en el diagrama qqnormal parece que se sigue una distribución normal al encontrarse muchos de los datos alineados, hay bastantes datos que se encuentran fuera de la linea de tendencia, por lo que no se cumple con normalidad en la cantidad de matrimonios por año.

En conclusión, la cantidad de matrimonios por año no sigue una distribución normal.

## Registros de Edad hombre
### Prueba de normalidad para la edad del hombre:

```{r normalHistEdadHombre, echo=FALSE}
#install.packages("ggplot2",repos = "http://cran.us.r-project.org")
library (ggplot2)
ggplot(data = datosMatrimonio, aes(x = EDADHOM)) + 
  geom_histogram(aes(y=..density.., fill = ..count..))+
  scale_fill_gradient(low = "#DCDCDC", high = "#7C7C7C")+
  stat_function(fun = dnorm, colour = "firebrick",
                args = list(mean = mean(datosMatrimonio$EDADHOM),
                            sd = sd(datosMatrimonio$EDADHOM)))+
  ggtitle("Histograma con curva normal teórica de las edades de los hombres (2011 - 2017)") + 
  theme_bw()
```  

En este histograma se puede observar que los datos tienen relativamente forma de campana, sin embargo, es evidente que estos tienen un sesgo hacia la izquierda, esto quiere decir que usualmente la edad entre los hombres en un matrimonio se encuentra debajo de los 30. Sin embargo, es importante mencionar que como dato interesante se puede observar que hay casos de matrimonios en hombres de más de 75 años. 
Debido al sesgo, la edad de los hombres en matrimonios no sigue una distribución normal.

### Diagrama de caja y bigotes

```{r normalBoxEdadHombre, echo=FALSE}
boxplot(datosMatrimonio$EDADHOM, main = "Caja y Bigotes de edad de los hombres al casarse (2011 - 2017)", xlab = "edad")
```

Se evidencia la gran cantidad de datos atípicos en el diagrama, se encuentran muy dispersos arriba de la media y del extremo superior que se encuentra al rededor de los 30 años. Esto quiere decir que la edad de los hombres en el matrimonio no sigue una distribución normal.

### Diagrama qqnormal

```{r normalQQEdadHombre, echo=FALSE}
qqnorm(datosMatrimonio$EDADHOM, col="blue")
qqline(datosMatrimonio$EDADHOM, col="red")
```

Como puede observarse, es muy notable en el diagrama qqnormal que los datos no siguen una distribución acorde a la linea de tendencia, esto quiere decir que la edad del hombre en el matrimonio no sigue una distribución normal.

En conclusión, la edad de los hombres en el matrimonio no sigue una distribución normal.

## Registros de edad de mujeres
### Prueba de normalidad para la edad de la mujer:

```{r normalHistEdadMuje, echo=FALSE}
#install.packages("ggplot2",repos = "http://cran.us.r-project.org")
library (ggplot2)
ggplot(data = datosMatrimonio, aes(x = EDADMUJ)) + 
  geom_histogram(aes(y=..density.., fill = ..count..))+
  scale_fill_gradient(low = "#DCDCDC", high = "#7C7C7C")+
  stat_function(fun = dnorm, colour = "firebrick",
                args = list(mean = mean(datosMatrimonio$EDADMUJ),
                            sd = sd(datosMatrimonio$EDADMUJ)))+
  ggtitle("Histograma con curva normal teórica de las edades de las mujeres (2011 - 2017)") + 
  theme_bw()
```  

De la misma manera que en el histograma de hombres, hay una forma relativa de campana, sin embargo se nota un gran sesgo a la izquierda que demuestra que la edad de mujeres en el matrimonio suele ser debajo de los 25, aunque también se cuentan con algunos datos arriba de los 75 años. Debido al sesgo, la edad de mujeres en el matrimonio no sigue una distribución normal.

### Diagrama de caja y bigotes

```{r normalBoxEdadMujer, echo=FALSE}
boxplot(datosMatrimonio$EDADMUJ, main = "Caja y Bigotes de edad de las mujeres al casarse (2011 - 2017)", xlab = "edad")
```

En este diagrama de caja y bigotes es posible ver una gran cantidad de datos atípicos arriba del extremo superior que se encuentra al rededor de los 30 años, muy similar al diagrama de la edad de los hombres, por lo que de la misma manera no se cuenta con normalidad en la edad de las mujeres en el matrimonio.

### Diagrama qqnormal

```{r normalQQEdadMujer, echo=FALSE}
qqnorm(datosMatrimonio$EDADMUJ, col="blue")
qqline(datosMatrimonio$EDADMUJ, col="red")
```

Como puede observarse, los valores en este diagrama evidentemente no siguen con una distribución normal ya que no esán sobre la linea de tendencia, por lo que la edad de las mujeres en el matrimonio no sigue una distribución normal.

En conclusión, la edad de las mujeres en el matrimonio no sigue una distribución normal.

#-----------------------------------------------------#
## Tabla de frecuencias para variables cualitativas

### Tabla de frecuencias para el departamento de ocurrencia y representación gráfica

```{r frecuenciaDepartamento, echo=FALSE}
table(datosMatrimonio$DEPOCU)
counts <- table(datosMatrimonio$DEPOCU)
barplot(counts, las = 2, cex.names=.5 ,main = "Distribución de departamento de ocurrencia (2011 - 2017)", xlab = "Departamento de ocurrencia")
```

Como puede observarse, el departamento en el que suele haber más matrimonios es en Guatemala, seguido por Huehuetenango y luego por Alta Verapaz.

### Tabla de frecuencias para el municipio de ocurrencia

```{r frecuenciaMunicipio, echo=FALSE}
#MuniOcurren <- data.frame(table(do.call(c, lapply(datosMatrimonio$MUPOCU, function(x) unlist(strsplit(x, "\\|"))))))
table(datosMatrimonio$MUPOCU)
counts <- table(datosMatrimonio$MUPOCU)
barplot(counts, las = 2, cex.names=.5 ,main = "Distribución de municipio de ocurrencia (2011 - 2017)", xlab = "Municipio de ocurrencia")
```

De la misma manera, es Guatemala el municipio que cuenta con la mayor cantidad de matrimonios.

### Tabla de frecuencias para la escolaridad del hombre
Donde:
1: ninguno
2: primaria
3: basica
4: diversificado
5: universitario
6: post grado
7: doctorado
9: ignorado

```{r frecuenciaEscolaridadHombre, echo=FALSE}
#EscolHom <- data.frame(table(do.call(c, lapply(datosMatrimonio$ESCHOM, function(x) unlist(strsplit(x, "\\|"))))))
table(datosMatrimonio$ESCHOM)
counts <- table(datosMatrimonio$ESCHOM)
barplot(counts, las = 1, cex.names=.8 ,main = "Distribución de escolaridad de los hombres (2011 - 2017)", xlab = "Escolaridad del hombre")
```

Como puede observarse, el nivel de escolaridad más común entre los hombres es primaria, con 255,480 casos, mientras que el más bajo es el de post grado con 181 casos.

### Tabla de frecuencias para la escolaridad de la Mujer
1: ninguno
2: primaria
3: basica
4: diversificado
5: universitario
6: post grado
7: doctorado
9: ignorado

```{r frecuenciaEscolaridadMujer, echo=FALSE}
#EscolMuj <- data.frame(table(do.call(c, lapply(datosMatrimonio$ESCMUJ, function(x) unlist(strsplit(x, "\\|"))))))
table(datosMatrimonio$ESCMUJ)
counts <- table(datosMatrimonio$ESCMUJ)
barplot(counts, las = 1, cex.names=.8 ,main = "Distribución de escolaridad de las mujeres (2011 - 2017)", xlab = "Escolaridad de las mujeres")
```

Como puede observarse, el nivel de escolaridad más común entre las mujeres es primaria, con 222076 casos, mientras que el más bajo es el de post grado con 126 casos.

### Tabla de frecuencias para el grupo étnico del hombre

```{r frecuenciaEtniaHombre, echo=FALSE}
#EtHom <- data.frame(table(do.call(c, lapply(datosMatrimonio$GETHOM, function(x) unlist(strsplit(x, "\\|"))))))
table(datosMatrimonio$PUEHOM)
counts <- table(datosMatrimonio$PUEHOM)
barplot(counts, las = 2, cex.names=.8 ,main = "Distribución de etnia de los hombres (2011 - 2017)", xlab = "Etnia del hombre")
```

Coomo puede observarse, el grupo étnico más común al que pertenecen los hombres en la base de datos es no indígena.

### Tabla de frecuencias para el grupo étnico de la mujer

```{r frecuenciaEtniaMujer, echo=FALSE}
#EtHom <- data.frame(table(do.call(c, lapply(datosMatrimonio$GETMUJ, function(x) unlist(strsplit(x, "\\|"))))))
table(datosMatrimonio$PUEMUJ)
counts <- table(datosMatrimonio$PUEMUJ)
barplot(counts, las = 2, cex.names=.8 ,main = "Distribución de etnia de las mujeres (2011 - 2017)", xlab = "Etnia de las mujeres")
```

De la misma manera, puede observarse que el grupo étnico más común al que pertenecen las mujeres en la base de datos es no indígena.

## Correlacion entre edades de los cónyuges

```{r CorrelacionEdades, echo=FALSE}
plot(x = datosMatrimonio$EDADHOM, y= datosMatrimonio$EDADMUJ, xlab= "Edad del Hombre", ylab= "Edad de la mujer", main = "Correlación entre las edades de los cónyuges (2011 - 2017)")
abline(lm(datosMatrimonio$EDADMUJ ~ datosMatrimonio$EDADHOM), col = "red")
```

Evidentemente no se puede observar correlación, sin embargo, es posible observar que hay hombres con edades muy altas con mujeres debajo de los 18 años,cabe mencionar que es importante filtrar los datos atipicos o norepresentativos del dataset

Como se puede ver, existen muchos datos extraños dentro del data set, estudiándolo se ha encontrado una gran cantidad de 1's y otros datos en donde la edad de los "cónyuges" es incluso menor a 5 años, por lo que la presencia de estos datos nos ha llevado a buscar la naturaleza de las variables, por lo que revisando la lista de variables del INE de cada año, pudimos darnos cuenta que la edad más pequeña para mujeres durante los años fue 12 y de los hombres 14, por lo tanto se hizo un nuevo dataset para estudiar con precisión lo que deseamos estudiar. Se ha filtrado de la base de datos de matrimonios los valores en donde la edad de la mujer era menor a 18 (por el objetivo) y mayor a 12 años (para eliminar los datos no significativos o no lógicos), asimismo se filtró los datos en donde el hombre es menor a 14 años (de igual manera para eliminar esos datos confusos).

```{r FiltroDeEdades, echo=FALSE}
#datosMatrimonio$EDADMUJ <- as.numeric(factor(datosMatrimonio$EDADMUJ))
menorEdadMuj <- datosMatrimonio %>% filter(EDADMUJ < 18)
menorEdadMuj <- menorEdadMuj %>% filter(EDADMUJ >= 12)
menorEdad <- menorEdadMuj %>% filter(EDADHOM >= 14)
```


```{r CorrEdadesFiltro, echo=FALSE}
plot(x = menorEdad$EDADHOM, y= menorEdad$EDADMUJ, xlab= "Edad del Hombre", ylab= "Edad de la mujer", main = "Correlación entre las edades, mujeres menores de 18 (2011 - 2017)")
abline(lm(menorEdad$EDADMUJ ~ menorEdad$EDADHOM), col = "red")
```

Filtrando los datos en donde las mujeres son menores a 18 años, es posible observar que una gran cantidad de mujeres se encuentran comprometidas con hombres mucho mayores a ellas, existen datos atípicos muy extensos y preocupantes, cabe mencionar que los datos que se encuentran en el fondo (muy pocos pero si existen) se encuentran así debido a que los datos no son indicados en el diagrama.

## Departamentos en donde se llevan a cabo los matrimonios de mujeres menores de edad

```{r tabla por departamentos del dataset, echo = FALSE}
library(dplyr)
library(magrittr)
menorEdadGraph <- menorEdad %>% filter(EDADHOM >= 18)
#departamentos
table(menorEdadGraph$DEPOCU)
counts <- table(menorEdadGraph$DEPOCU)
barplot(counts, las = 2, cex.names=.6 ,main = "Departamentos con matrimonios con menores de edad (2011 - 2017)", xlab = "Departamentos de ocurrencia")
```

Puede observarse que muchos de estos matrimonios se llevan a cabo en el departamento de Guatemala, donde una gran población son ladinos.

## Municipios en donde se llevan a cabo los matrimonios de mujeres menores de edad

```{r tabla por municipios de casamientos, echo = FALSE}
library(dplyr)
library(magrittr)
depMun <- (menorEdadGraph$MUPOCU)
#departamentos
table(depMun)
counts <- table(menorEdadGraph$MUPOCU)
barplot(counts, las = 2, cex.names=.5 ,main = "Municipios con matrimonios con menores de edad (2011 - 2017)", xlab = "Municipios de ocurrencia")
```

De la misma manera, puede observarse que la mayor cantidad de ocurrencias se encuentra en Guatemala.

## La etnia de la mujer en donde es más común este evento

```{r tabla por etnia de la mujer, echo = FALSE}
library(dplyr)
library(magrittr)
etniaMujer <- (menorEdadGraph$PUEMUJ)
#departamentos
table(etniaMujer)
counts <- table(menorEdadGraph$PUEMUJ)
barplot(counts, las = 2, cex.names=.8 ,main = "Etnia de mujeres involucradas en matrimonios con menores de edad (2011 - 2017)", xlab = "Etnia de las mujeres")
```

Se puede observar que no hay una diferencia significativa en estos grupos, lo cual es importante para saber si el hecho de que ocurran los matrimonios con menores de edad, es algo que se ve influido por la cultura.

## La etnia del hombre en donde es más común este evento

```{r tabla por etnia del hombre, echo = FALSE}
library(dplyr)
library(magrittr)
etniaHombre <- (menorEdadGraph$PUEHOM)
#departamentos
table(etniaHombre)
counts <- table(menorEdadGraph$PUEHOM)
barplot(counts, las = 2, cex.names=.8 ,main = "Etnia de hombres involucrados en matrimonios con menores de edad (2011 - 2017)", xlab = "Etnia de los hombres")
```


Se puede observar que no hay una diferencia significativa en estos grupos, lo cual es importante para saber si el hecho de que ocurran los matrimonios con menores de edad, es algo que se ve influido por la cultura.

## Escolaridad del hombre involucrado en este evento
Donde:
1: ninguno
2: primaria
3: basica
4: diversificado
5: universitario
6: post grado
7: doctorado
9: ignorado

```{r frecuenciaEscolaridadHombreMenor, echo=FALSE}
library(RColorBrewer)
coul <- brewer.pal(8,"Set2")
counts <- table(menorEdadGraph$ESCHOM)
barplot(counts, las = 1, cex.names=.8 , xlab = "Escolaridad del hombre", col = coul)
```

## Escolaridad de la mujer involucrada en este evento
Donde:
1: ninguno
2: primaria
3: basica
4: diversificado
5: universitario
6: post grado
7: doctorado
9: ignorado
```{r frecuenciaEscolaridadMujer2, echo=FALSE}
coul <- brewer.pal(8,"Set2")
counts <- table(menorEdadGraph$ESCMUJ)
barplot(counts, las = 1, cex.names=.8 , xlab = "Escolaridad de las mujeres", col = coul)
```

## Ocurrencia de matrimonios con menores de edad desde 2011 a 2017

```{r matrimoniosMenorses, echo=FALSE}
coul <- brewer.pal(8,"Set2")
counts <- table(menorEdadGraph$AÑOOCU)
barplot(counts, las = 1, cex.names=.8 , xlab = "Año de ocurrencia", col = coul)
``` 

```{r}
library(haven)
library(foreign)

set.seed(123)

nacimientos2011 <- read_sav("./SAVS/2011N.sav")
nacimientos2012 <- read_sav("./SAVS/2012Nacimientos.sav")
nacimientos2013 <- read_sav("./SAVS/2013N.sav")
nacimientos2014 <- read_sav("./SAVS/2014N.sav")
nacimientos2015 <- read_sav("./SAVS/2015N.sav")
nacimientos2016 <- read_sav("./SAVS/2016N.sav")
nacimientos2017 <- read_sav("./SAVS/2017N.sav")
nacimientos2018 <- read_sav("./SAVS/2018N.sav")
nacimientos2019 <- read_sav("./SAVS/2019N.sav")



```

#Histograma nacimientos 2011
```{r}
library(dplyr)
library(ggplot2)
barplot(table(nacimientos2011$Edadm), main = "Edad de madres en nacimientos 2011", xlab = "Edad", ylab = "Cantidad", col = "steelblue" , border = "pink")
```

#Histograma nacimientos 2012
```{r}
library(dplyr)
library(ggplot2)
barplot(table(nacimientos2012$Edadm), main = "Edad de madres en nacimientos 2012", xlab = "Edad", ylab = "Cantidad", col = "steelblue" , border = "pink")
```


#Histograma nacimientos 2013
```{r}
library(dplyr)
library(ggplot2)
barplot(table(nacimientos2013$Edadm), main = "Edad de madres en nacimientos 2013", xlab = "Edad", ylab = "Cantidad", col = "steelblue" , border = "pink")
```

#Histograma nacimientos 2014
```{r}
library(dplyr)
library(ggplot2)
barplot(table(nacimientos2014$Edadm), main = "Edad de madres en nacimientos 2014", xlab = "Edad", ylab = "Cantidad", col = "steelblue" , border = "pink")
```

#Histograma nacimientos 2015
```{r}
library(dplyr)
library(ggplot2)
barplot(table(nacimientos2015$Edadm), main = "Edad de madres en nacimientos 2015", xlab = "Edad", ylab = "Cantidad", col = "steelblue" , border = "pink")
```

#Histograma nacimientos 2016
```{r}
library(dplyr)
library(ggplot2)
barplot(table(nacimientos2016$Edadm), main = "Edad de madres en nacimientos 2016", xlab = "Edad", ylab = "Cantidad", col = "steelblue" , border = "pink")
```

#Histograma nacimientos 2017
```{r}
library(dplyr)
library(ggplot2)
barplot(table(nacimientos2017$Edadm), main = "Edad de madres en nacimientos 2017", xlab = "Edad", ylab = "Cantidad", col = "steelblue" , border = "pink")
```


#Histograma nacimientos 2018
```{r}
library(dplyr)
library(ggplot2)
barplot(table(nacimientos2018$Edadm), main = "Edad de madres en nacimientos 2018", xlab = "Edad", ylab = "Cantidad", col = "steelblue" , border = "pink")
```


#Histograma nacimientos 2019
```{r}
library(dplyr)
library(ggplot2)
barplot(table(nacimientos2019$Edadm), main = "Edad de madres en nacimientos 2019", xlab = "Edad", ylab = "Cantidad", col = "steelblue" , border = "pink")
```

```{r}
library(haven)
library(dplyr)
X20111 <- read_sav("SAVS/20111.sav")

X20122 <- read_sav("SAVS/20122.sav")

X2013 <- read_sav("SAVS/2013M.sav")

X2014 <- read_sav("SAVS/2014M.sav")

X2015 <- read_sav("SAVS/2015M.sav")

X2016 <- read_sav("SAVS/2016M.sav")

X2017 <- read_sav("SAVS/2017M.sav")

X2018 <- read_sav("SAVS/2018M.sav")

X2019 <- read_sav("SAVS/2017M.sav")

datos2011 <- sum(X20111$Edadmuj < 18)

datos2012 <- sum(X20122$EDADMUJ < 18)

datos2013 <- sum(X2013$EDADMUJ < 18)

datos2014 <- sum(X2014$EDADMUJ < 18)

datos2015 <- sum(X2015$EDADMUJ < 18)

datos2016 <- sum(X2016$EDADMUJ < 18)

datos2017 <- sum(X2017$EDADMUJ < 18)

datos2018 <- sum(X2018$EDADMUJ < 18)

datos2019 <- sum(X2019$EDADMUJ < 18)

library(ggplot2)
df <- data.frame (año  = c("2011", "2012", "2013", "2014", "2015", "2016", "2017", "2018", "2019"),
                  matrimonios = c(datos2011, datos2012, datos2013, datos2014, datos2015, datos2016, datos2017, datos2018, datos2019)
                  )
print(df)

ggplot(df, aes(x=año, y=matrimonios, group = 1)) + 
  geom_point(size = 2, color = "green") + 
  geom_line(color="green") +
  labs(x = "Año", y = "Matrimonios menores de edad", title = "cantidad de matrimonios menores de edad de 2011 al 2019")
```

Como podemos ver en nuestra grafica de tendencia, y la tabla de matrimonios, se puede ver que en los años donde hay mayores matrimonios en menores de edad, es en los años 2011 y 2012, luego fue bajando hasta el año 2016 donde se tubo 65 matrimonios reportados, un año antes de la prohibicion de matrimonios en menores de edad, luego se mantuvo bajo, en 2018 no se reportaron matrimonios en menores de edad, pero en 2019 se reportaron 22 matrimonios.

# -----------------------------------Clustering--------------------------------

```{r Preprocesamiento, echo=FALSE}
menorEdad$AÑOOCU <- as.numeric(factor(menorEdad$AÑOOCU))
datosClustering <- menorEdad[,c(4,6,7,20)]
data_omit <- na.omit(datosClustering) 
summary(datosClustering)
```

Se trabajará con las siguientes variables que tienen formato int para formas grupos: AÑOREG, ALOOCU, EDADHOM,EDADMUJ. Esto debido a que son variables que se pueden clasificar por grupos y los resultados pueden ser interpretados.

Para saber la mejor cantidad de clusters a utilizar, se hará lo siguiente:

```{r cantClusters, echo=FALSE}
wss <- (nrow(data_omit[,1:4])-1)*sum(apply(data_omit[,1:4],2,var))
for (i in 2:10) 
  wss[i] <- sum(kmeans(data_omit[,1:4], centers=i)$withinss)
plot(1:10, wss, type="b", xlab="Number of Clusters",  ylab="Within groups sum of squares")
```

Puede observarse en el gráfico que el codo se encuentra en el valor 2, por lo que esta es la cantidad adecuada de clusters que se deben utilizar.

## Agrupamiento por medio de k-means  

```{r kmeans, echo=FALSE}
library(fpc)
km<-kmeans(datosClustering[,1:4],2,iter.max =100)
datosClustering$grupo<-km$cluster
plotcluster(datosClustering[,1:4],km$cluster)
gkm1<- datosClustering[datosClustering$grupo==1,]
gkm2<- datosClustering[datosClustering$grupo==2,]
# gkm3<- datosClustering[datosClustering$grupo==3,]
# gkm4<- datosClustering[datosClustering$grupo==4,]
# gkm5<- datosClustering[datosClustering$grupo==5,]
# gkm6<- datosClustering[datosClustering$grupo==6,]
# gkm7<- datosClustering[datosClustering$grupo==7,]
```

Se puede observar cómo los datos se encuentran divididos en 2 grupos, todos bastante concentrados a excepcion de algunos datos atipicos del grupo mas alejado, estos son alrededor de 40 matrimonios donde los hombres eran de edades de 80 - 60 con niñas menores de edad.

## Mixture of gaussians

```{r gaussians, echo = FALSE}
library(mclust)
mc<-Mclust(datosClustering[,1:4],2)
plot(mc, what = "classification", main="MClust Classification")
datosClustering$mxGau<-mc$classification
g1PMC<-datosClustering[datosClustering$mxGau==1,]
g2PMC<-datosClustering[datosClustering$mxGau==2,]
# g3PMC<-datosClustering[datosClustering$mxGau==3,]
# g4PMC<-datosClustering[datosClustering$mxGau==4,]
# g5PMC<-datosClustering[datosClustering$mxGau==5,]
# g6PMC<-datosClustering[datosClustering$mxGau==6,]
# g7PMC<-datosClustering[datosClustering$mxGau==7,]
```
En este gráfico se puede observar como en cada combinación de gráficos sucede la combinación de grupos y se observan los clusters bastante separados y bien identificados.

## Fuzzy C-means

```{r fuzzy2, echo=FALSE}
library(e1071)#para cmeans
library(cluster)
set.seed(123)
fcmf<-cmeans(datosClustering[,1:4],2)
datosClustering$FCGrupos<-fcmf$cluster
g1FCM <- datosClustering[datosClustering$FCGrupos == 1,]
g2FCM <- datosClustering[datosClustering$FCGrupos == 2,]
# g3FCM <- datosClustering[datosClustering$FCGrupos == 3,]
# g4FCM <- datosClustering[datosClustering$FCGrupos == 4,]
# g5FCM <- datosClustering[datosClustering$FCGrupos == 5,]
# g6FCM <- datosClustering[datosClustering$FCGrupos == 6,]
# g7FCM <- datosClustering[datosClustering$FCGrupos == 7,]

clusplot(datosClustering, fcmf$cluster, color=TRUE, shade = TRUE, labels = 2,lines = 0)

library(fpc)
plotcluster(datosClustering,fcmf$cluster)
```
En el primer gráfico, clusplot, se puede ver detrás las regiones y como se encuentran los datos, además se indica que se explica casi 64% del punto de variabilidad.

En el segundo gráfico se encuentran ya separados los clusters y es posible observar la variabilidad entre ellos.

```{r analisis de cada grupo kmeans, echo=FALSE}
summary(gkm1)
summary(gkm2)
# summary(gkm3)
# summary(gkm4)
# summary(gkm5)
# summary(gkm6)
# summary(gkm7)
```

Observando los resúmenes de cada cluster podemos darnos cuenta que en el clustering por kmeans podemos observar que una de las divisiones más evidentes se realizó por la edad del hombre, en donde el grupo 1 tiene los que se encuentran entre 14-22, el 2 entre 22-39, el 3 entre 40-86 y el 4 parece ser un complemento del 1 en donde se encuentran los de 14-24. Las edades de las mujeres de los grupos no parece ser un factor determinante al igual que el año de registro.

```{r analisis de cada grupo mixture gaussians, echo=FALSE}
summary(g1PMC)
summary(g2PMC)
# summary(g3PMC)
# summary(g4PMC)
# summary(g5PMC)
# summary(g6PMC)
# summary(g7PMC)
```

En este resúmen podemos identificar que se agrupo principalmente en relación al año, el grupo 1 se encuentran los años 2015-2020, 2 2012-2015, 3 2009,2012 y el 4to parece ser un complemento del 1ro. las edades parecen ser similares a través de los grupos.

```{r analisis de cada grupo fuzzy c means, echo=FALSE}
summary(g1FCM)
summary(g2FCM)
# summary(g3FCM)
# summary(g4FCM)
# summary(g5FCM)
# summary(g6FCM)
# summary(g7FCM)
```

En el resúmer por fuzzy se puede identificar que la media de la edad de las mujeres parece ser constante, los años un poco variados pero en cierta manera se observa una relación entre año y edad del hombre.

## Evaluación de la tendencia de agrupamiento:

En esté análisis de datos consiste en examinar si los datos son agrupables, es decir, si los datos contienen cualquier estructura de agrupación inherente. Esto debe comprobarse antes de aplicar el análisis de agrupación.

Hopkins estadística: si el valor de Hopkins estadística está cerca de cero muy por debajo de 0,5, entonces podemos concluir que el conjunto de datos es significativamente clusterable.
VAT evaluación visual de la tendencia de agrupamiento: la cubeta detecta la tendencia de agrupamiento en una forma visual contando el número de bloques oscuros o coloreados de forma cuadrada a lo largo de la diagonal en una imagen de rectangulos.

### En hombres

```{r Evaluacion de la tendencia de agrupamiento:cluster jerarquico, echo=FALSE}
clarax <- clara(datosMatrimonio$EDADMUJ , 2)
# Cluster plot
  
plot(silhouette(clarax),  col = 2:3, main = "Silhouette plot")  
```
Nos podemos dar cuenta que para la silueta con dos clusters nos presenta un valor bastante alto por encima de .5, indicandonos la distribucion de grupos de forma optima, nuestra silueta para hombres presenta 0.67, utilizando dos clusters se interpretan de mejor forma a comparacion con 2 clusteres.
### En mujeres

```{r elegir los algoritmos de agrupación apropiados, echo=FALSE}
clorax <- clara(datosMatrimonio$EDADHOM , 2)
# Cluster plot
plot(silhouette(clorax),  col = 2:3, main = "Silhouette plot")
```
Similar que para el cluster de hombres, para mujeres tambien tenemos 0.66 u dato bastante alto, indicandonos tambien que utilizar dos clusters es la forma optima de interpretar nuestros conjuntos de datos

#---------------------------Apartado de predición----------------------------------

Con el fin de poder investigar más a fondo bajo que criterios es más probable que en un casamiento se encuentre implicada una mujer menor de edad (que en el análisis anterior se evidenció era más recurrente que los hombres) se decidió utilizar ML para poder predecir si dadas ciertas características una mujer será menor de edad en un matrimonio, para poder determinar en que lugares (o situaciones) debe ser atendido este problema.

Con el objetivo de poder estudiar por categorias, se realizará una variable de clasificación adicional en el dataframe para poder llevar a cabo la predicción, en este caso se separó por menores y mayores de edad.

```{r Clasificación, echo=FALSE}
datosMatrimonio$clasificacion <- ifelse(datosMatrimonio$EDADMUJ <= 17, "Menor", ifelse(datosMatrimonio$EDADMUJ >= 18, "Mayor",NA))
datosMatrimonio$y <- factor(datosMatrimonio$clasificacion)
```

A su vez, es necesario convertir todos los datos a factores para poder hacer un análisis con RWEKA

```{r Filtrado, echo=FALSE}
datosML <- datosMatrimonio %>% filter(EDADMUJ >= 12)
datosML <- datosML %>% filter(EDADHOM >= 14)
datosML <- datosML[,-24]
datosML <- datosML[,-7]
datosML <- datosML[complete.cases(datosML), ]
#
datosML$DEPREG <- as.factor(datosML$DEPREG)
datosML$MUPREG <- as.factor(datosML$MUPREG)
datosML$MESREG <- as.factor(datosML$MESREG)
datosML$CLAUNI <- as.factor(datosML$CLAUNI)
datosML$PUEHOM <- as.factor(datosML$PUEHOM)
datosML$PUEMUJ <- as.factor(datosML$PUEMUJ)
datosML$NACHOM <- as.factor(datosML$NACHOM)
datosML$NACMUJ <- as.factor(datosML$NACMUJ)
datosML$CIUOHOM <- as.factor(datosML$CIUOHOM)
datosML$CIUOMUJ <- as.factor(datosML$CIUOMUJ)
datosML$NUNUHO <- as.factor(datosML$NUNUHO)
datosML$NUNUMU <- as.factor(datosML$NUNUMU)
datosML$DEPOCU <- as.factor(datosML$DEPOCU)
datosML$MUPOCU <- as.factor(datosML$MUPOCU)
datosML$MESOCU <- as.factor(datosML$MESOCU)
datosML$AREAGOCU <- as.factor(datosML$AREAGOCU)
datosML$ESCHOM <- as.factor(datosML$ESCHOM)
datosML$ESCMUJ <- as.factor(datosML$ESCMUJ)
datosML$DIAOCU <- as.factor(datosML$DIAOCU)
datosML$AÑOOCU <- as.factor(datosML$AÑOOCU)
```

Luego, hacemos los conjuntos de entrenamiento y prueba y se borran las bases de datos de cada año individuales para liberar espacio en la memoria de R

```{r limpiezarm, echo=FALSE}
rm(l)
rm(datosMatrimonio)
rm(datos2011)
rm(datos2012)
rm(datos2013)
rm(datos2014)
rm(datos2015)
rm(datos2016)
rm(datos2017)
rm(datosNacim2011)
rm(datosNacim2012)
rm(datosNacim2015)
rm(datosNacim2016)
rm(datosNacim2019)
rm(datosN2013)
rm(datosN2014)
rm(nacimientos2011)
rm(nacimientos2012)
rm(nacimientos2013)
rm(nacimientos2014)
rm(nacimientos2015)
rm(nacimientos2016)
rm(nacimientos2017)
rm(nacimientos2018)
rm(nacimientos2019)
rm(X20111)
rm(X20122)
rm(X2013)
rm(X2014)
rm(X2015)
rm(X2016)
rm(X2017)
rm(X2018)
rm(X2019)
rm(g1FCM)
rm(g1PMC)
rm(g2FCM)
rm(g2PMC)
rm(gkm1)
rm(gkm2)
rm(mc)
rm(fcmf)
rm(modelo)
rm(clarax)
rm(clorax)
rm(data_omit)
rm(menorEdad)
rm(menorEdadGraph)
rm(menorEdadMuj)
```

## Segundo análisis de datos
Debido a que al tratar de hacer las predicciones se ha contado con errores debido a la gran cantidad que se está manejando, se ha decidido verificar cuáles son las variables más significativas para trabajar únicamente con ellas, sin embargo, al contar con variables que no son únicamente numéricas no es posible realizar una correlación entre ellas, por lo que se ha estudiado los datos de cada variable y se ha discutido su importancia, llegando a lo siguiente:

En el caso de la ocupación, tanto de hombres como mujeres, se cuenta con demasiados valores diferentes por lo que no se considera que sea significativo. En el caso de los hombres se cuenta con 489 diferentes ocupaciones y en el caso de las mujeres se cuenta con 487 ocupaciones diferentes.
El número de nupcias también es ignorado ya que los valores de "ignorado" y "none" representan en hombres el 37.0% y el 44.61% respectivamente y en mujeres representa el 37.06% y 44.61% respectivamente, por lo que no se vuelve tan significativo.

La variable de escolaridad tanto de hombres como mujeres también será eliminada ya que los valores de ignorado y ninguno representan un 13.35% y 21.89% para los hombres y un 13.06% y 30.68% para las mujeres.
Por último, aquellos datos que tengan el registro, como el departamento de ocurrencia o el municipio de ocurrencia, también serán eliminados debido a que es más confiable trabajar con los datos de ocurrencia, porque en muchos casos se registran matrimonios tiempo después de que hayan ocurrido o incluso en lugares diferentes, por lo que los datos de registro no son tan confiables, además, en caso de que sí se haya registrado en la fecha y lugares correctos, se tendría los datos duplicados.

Por lo que nos quedamos con los valores de: Clase de unión, edad del hombre, etnia del hombre y de la mujer, nacionalidad del hombre y mujer, departamento, municipio, mes, año, día y área de ocurrencia y la variable a predecir que es si la mujer es mayor o menor de edad


```{r delvar, echo=TRUE}
datosML <- datosML[,c(5,6,7,8,9,10,15,16,17,18,19,22,23)]
porciento <- 70/100
set.seed(123)
trainRowsNumber<-sample(nrow(datosML),porciento*nrow(datosML))
train<-datosML[trainRowsNumber,]
test<-datosML[-trainRowsNumber,]
```

Para poder escoger los grupos de entrenamiento y prueba se ha utilizado el 70% del total de los datos para el entrenamiento y el 30% restante para la prueba, esto para que se cuente con una cantidad significativa de datos para así mejorar el entrenamiento de los mismos sin que se aprendan patrones específicos.



## Predicción por medio de Naive Bayes

```{r bayes, echo=FALSE}
library(e1071)
modelo <- naiveBayes(train$y~., data = train)
predBayes <- predict(modelo, newdata = train[,1:13])
cm<- caret::confusionMatrix(predBayes,train$y)
cm
predBayesM <- predict(modelo, newdata = test[,1:13])
test$PredBayes <- predBayesM
cm <- caret::confusionMatrix(test$PredBayes, test$y)
cm
```

Se utilizó Naive Bayes, que se basa en la fórmula estadística de bayes la cuál modela la probabilidad de que sucede un suceso en base a que otro previamente ha sucedido. Al ver el porcentaje de acierto del algoritmo, se puede notar que acertó en un 69% por lo que si parece haber patrones que determinan si la mujer es menor o mayor de edad. Adicionalmente, si vemos la matriz de confusión al momento de predecir si es mayor, suele ser bastante preciso, sin embargo, predijo que muchas mujeres eran mayores de edad cuando en realidad no lo eran, aún así, tambien es notable, al ver la matriz de confusión y el porcentaje de acierto que las variables si influencian el estado de la mujer al casarse.
Es más conveniente usar Naive Bayes y árboles de decisión. En el caso de contar con mayor capacidad computacional podría intentar hacerse una red neuronal más completa con un tiempo menor y quizás obtener mejores resultados.



## Prediccion por medio de árboles de decisión


```{r arbolRpart, echo=FALSE}
#con caret
library (caret)
ct<-trainControl(method = "cv",train[,1:13],number=10, verboseIter=T)
modelorf<-train(y~.,data=train,method="rpart",trControl = ct)
prediccionADVC<-predict(modelorf,newdata = test[,1:13])
test$predADVC<-prediccionADVC
cfmCaret <- confusionMatrix(test$predADVC,test$y)
cfmCaret
```

Se realizó un modelo de arbol de clasificación por caret utilizando el método por partición recursiva utilizando un analisis multivariable para modelar la influencia de los atributos sobre la variable respuesta, en este caso si la mujer es menor o mayor de edad. Se puede observar en el análisis que la predicción tuvo una eficiencia de casi 78%, además, en la matriz de confusión se puede observar que predijo que 2953 eran menores de edad cuando en realidad eran mayores, por el otro lado predijo que 2581 mujeres eran mayores cuando en realidad eran menores, en sí esto es un número de equivocaciones significativamente preocupantes, sin embargo, al ver cuantas fueron sus predicciones acertadas, se puede determinar que efectivamente si la mujer es menor o mayor de edad se encuentra influenciada por variables como la edad del hombre, área geográfica, nacionalidad etc. 

## Prediccion por redes neuronales: RWEKA

Se ha definido el uso de 13 nodos, que representan las 13 columnas a utilizar con los respectivos datos, a partir de esto puede observarse cómo es que se toman cada uno de los valores de las respectivas columnas y todo llega a una variable respuesta, por lo que se cuenta con una capa de entrada, en donde se reciben las señales de entrada, se cuenta con la capa oculta que es la que define la topología de toda la red pero no es posible observar y por último se cuenta con la capa de salida, que recibe la información de la capa oculta para poder transmitir la respuesta obtenida.

```{r Rweka clasificación, echo=FALSE}
#datosML <- lapply(datosML, as.factor)
#install.packages("RWeka")
library(RWeka)
NB <- make_Weka_classifier("weka/classifiers/functions/MultilayerPerceptron")
NB 
WOW(NB)
nnodos='13'
modelo.bp<-NB(datosML$y~., data=datosML,subset = trainRowsNumber, control=Weka_control(H=nnodos, N=1, G=TRUE), options=NULL)
test$prediccionWeka<-predict(modelo.bp, newdata = test[,1:13])
cfmWeka<-confusionMatrix(test$prediccionWeka,test$y)
cfmWeka
```

Utilizando redes neuronales por Rweka se obtuvo un porcentaje de casi 66% en donde, si se observa la matriz de confusión, el algoritmo realmente predijo que todas las mujeres en base a los datos de test serían mayores de edad, situación que evidentemente no sucede, es posible que esto se deba a que los datos no muestran realmente un patrón evidente en el cuál se identifique un set de características para poder diferenciar estos dos grupos.


